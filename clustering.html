
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clustering {#clustering} &#8212; DSCΙ 100</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Statistical inference {#inference}" href="inference.html" />
    <link rel="prev" title="Regression II: linear regression {#regression2}" href="regression2.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      
      <h1 class="site-logo" id="site-title">DSCΙ 100</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   R and the Tidyverse hello worldV
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  First draft
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="preface-text.html">
   Preface {-}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="setup.html">
   Setting up your computer {#move-to-your-own-machine}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="reading.html">
   Reading in data locally and from the web {#reading}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wrangling.html">
   Cleaning and wrangling data {#wrangling}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="viz.html">
   Effective data visualization {#viz}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="version-control.html">
   Collaboration with version control {#Getting-started-with-version-control}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="classification1.html">
   Classification I: training &amp; predicting {#classification}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="classification2.html">
   Classification II: evaluation &amp; tuning {#classification2}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="regression1.html">
   Regression I: K-nearest neighbors {#regression1}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="regression2.html">
   Regression II: linear regression {#regression2}
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Clustering {#clustering}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="inference.html">
   Statistical inference {#inference}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="references.html">
   References {-}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="acknowledgements.html">
   Acknowledgments {-}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="authors.html">
   About the authors {-}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="appendixA.html">
   (APPENDIX) Appendix {-}
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="_sources/clustering.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/clustering.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/phaustin/eosc211_students/e211_live_main?urlpath=tree/clustering.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        <a class="jupyterhub-button" href="https://eosc211.jupyterhub.eoas.ubc.ca/jupyter/hub/user-redirect/git-pull?repo=https://github.com/phaustin/eosc211_students&urlpath=tree/eosc211_students/clustering.md&branch=e211_live_main"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch JupyterHub" data-toggle="tooltip"
                data-placement="left"><img class="jupyterhub-button-logo"
                    src="_static/images/logo_jupyterhub.svg"
                    alt="Interact on JupyterHub">JupyterHub</button></a>
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#overview">
   Overview
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#chapter-learning-objectives">
   Chapter learning objectives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#clustering">
   Clustering
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#k-means">
   K-means
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#measuring-cluster-quality">
     Measuring cluster quality
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-clustering-algorithm">
     The clustering algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#random-restarts">
     Random restarts
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#choosing-k">
     Choosing K
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#data-pre-processing-for-k-means">
   Data pre-processing for K-means
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#k-means-in-r">
   K-means in R
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#additional-resources">
   Additional resources
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Clustering {#clustering}</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#overview">
   Overview
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#chapter-learning-objectives">
   Chapter learning objectives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#clustering">
   Clustering
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#k-means">
   K-means
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#measuring-cluster-quality">
     Measuring cluster quality
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-clustering-algorithm">
     The clustering algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#random-restarts">
     Random restarts
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#choosing-k">
     Choosing K
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#data-pre-processing-for-k-means">
   Data pre-processing for K-means
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#k-means-in-r">
   K-means in R
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#additional-resources">
   Additional resources
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="clustering-clustering">
<h1>Clustering {#clustering}<a class="headerlink" href="#clustering-clustering" title="Permalink to this headline">¶</a></h1>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>library(knitr)
library(RColorBrewer)
library(gridExtra)
library(cowplot)
library(broom)
library(egg) # ggarrange


#center breaks latex here
knitr::opts_chunk$set(warning = FALSE, fig.align = &quot;default&quot;) 

# set the colors in the graphs, 
# some graphs with the code shown to students are hard coded 
cbbPalette &lt;- c(brewer.pal(9, &quot;Paired&quot;))
cbpalette &lt;- c(&quot;darkorange3&quot;, &quot;dodgerblue3&quot;, &quot;goldenrod1&quot;)

theme_update(axis.title = element_text(size = 12)) # modify axis label size in plots 
</pre></div>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>As part of exploratory data analysis, it is often helpful to see if there are
meaningful subgroups (or <em>clusters</em>) in the data.
This grouping can be used for many purposes,
such as generating new questions or improving predictive analyses.
This chapter provides an introduction to clustering
using the K-means algorithm,
including techniques to choose the number of clusters.</p>
</div>
<div class="section" id="chapter-learning-objectives">
<h2>Chapter learning objectives<a class="headerlink" href="#chapter-learning-objectives" title="Permalink to this headline">¶</a></h2>
<p>By the end of the chapter, readers will be able to do the following:</p>
<ul class="simple">
<li><p>Describe a case where clustering is appropriate,
and what insight it might extract from the data.</p></li>
<li><p>Explain the K-means clustering algorithm.</p></li>
<li><p>Interpret the output of a K-means analysis.</p></li>
<li><p>Differentiate between clustering and classification.</p></li>
<li><p>Identify when it is necessary to scale variables before clustering,
and do this using R.</p></li>
<li><p>Perform K-means clustering in R using <code class="docutils literal notranslate"><span class="pre">kmeans</span></code>.</p></li>
<li><p>Use the elbow method to choose the number of clusters for K-means.</p></li>
<li><p>Visualize the output of K-means clustering in R using colored scatter plots.</p></li>
<li><p>Describe the advantages,
limitations and assumptions of the K-means clustering algorithm.</p></li>
</ul>
</div>
<div class="section" id="clustering">
<h2>Clustering<a class="headerlink" href="#clustering" title="Permalink to this headline">¶</a></h2>
<p>Clustering \index{clustering} is a data analysis task
involving separating a data set into subgroups of related data.
For example, we might use clustering to separate a
data set of documents into groups that correspond to topics, a data set of
human genetic information into groups that correspond to ancestral
subpopulations, or a data set of online customers into groups that correspond
to purchasing behaviors.  Once the data are separated, we can, for example,
use the subgroups to generate new questions about the data and follow up with a
predictive modeling exercise. In this course, clustering will be used only for
exploratory analysis, i.e., uncovering patterns in the data.</p>
<p>Note that clustering is a fundamentally different kind of task
than classification or regression.
In particular, both classification and regression are <em>supervised tasks</em>
\index{classification}\index{regression}\index{supervised}
where there is a <em>response variable</em> (a category label or value),
and we have examples of past data with labels/values
that help us predict those of future data.
By contrast, clustering is an <em>unsupervised task</em>,
\index{unsupervised} as we are trying to understand
and examine the structure of data without any response variable labels
or values to help us.
This approach has both advantages and disadvantages.
Clustering requires no additional annotation or input on the data.
For example, it would be nearly impossible to annotate
all the articles on Wikipedia with human-made topic labels.
However, we can still cluster the articles without this information
to find groupings corresponding to topics automatically.</p>
<p>Given that there is no response variable, it is not as easy to evaluate
the “quality” of a clustering.  With classification, we can use a test data set
to assess prediction performance. In clustering, there is not a single good
choice for evaluation. In this book, we will use visualization to ascertain the
quality of a clustering, and leave rigorous evaluation for more advanced
courses.</p>
<p>As in the case of classification,
there are many possible methods that we could use to cluster our observations
to look for subgroups.
In this book, we will focus on the widely used K-means \index{K-means} algorithm [&#64;kmeans].
In your future studies, you might encounter hierarchical clustering,
principal component analysis, multidimensional scaling, and more;
see the additional resources section at the end of this chapter
for where to begin learning more about these other methods.</p>
<p>\newpage</p>
<blockquote>
<div><p><strong>Note:</strong> There are also so-called <em>semisupervised</em> tasks, \index{semisupervised}
where only some of the data come with response variable labels/values,
but the vast majority don’t.
The goal is to try to uncover underlying structure in the data
that allows one to guess the missing labels.
This sort of task is beneficial, for example,
when one has an unlabeled data set that is too large to manually label,
but one is willing to provide a few informative example labels as a “seed”
to guess the labels for all the data.</p>
</div></blockquote>
<p><strong>An illustrative example</strong></p>
<p>Here we will present an illustrative example using a data set \index{Palmer penguins} from
<a class="reference external" href="https://allisonhorst.github.io/palmerpenguins/">the <code class="docutils literal notranslate"><span class="pre">palmerpenguins</span></code> R package</a> [&#64;palmerpenguins]. This
data set was collected by Dr. Kristen Gorman and
the Palmer Station, Antarctica Long Term Ecological Research Site, and includes
measurements for adult penguins found near there [&#64;penguinpaper]. We have
modified the data set for use in this chapter. Here we will focus on using two
variables—penguin bill and flipper length, both in millimeters—to determine whether
there are distinct types of penguins in our data.
Understanding this might help us with species discovery and classification in a data-driven
way.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span># image source: https://commons.wikimedia.org/wiki/File:Gentoo_Penguin._(8671680772).jpg
knitr::include_graphics(&quot;img/gentoo.jpg&quot;)
</pre></div>
</div>
<p>To learn about K-means clustering
we will work with <code class="docutils literal notranslate"><span class="pre">penguin_data</span></code> in this chapter.
<code class="docutils literal notranslate"><span class="pre">penguin_data</span></code> is a subset of 18 observations of the original data,
which has already been standardized
(remember from Chapter &#64;ref(classification)
that scaling is part of the standardization process).
We will discuss scaling for K-means in more detail later in this chapter.
\index{mutate}\index{read function!read_csv}</p>
<p>Before we get started, we will load the <code class="docutils literal notranslate"><span class="pre">tidyverse</span></code> metapackage
as well as set a random seed.
This will ensure we have access to the functions we need
and that our analysis will be reproducible.
As we will learn in more detail later in the chapter,
setting the seed here is important
because the K-means clustering algorithm uses random numbers.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>library(tidyverse)

data &lt;- read_csv(&quot;data/toy_penguins.csv&quot;) |&gt;
  mutate(cluster = as_factor(cluster)) |&gt;
  mutate(flipper_length_standardized = as.double(scale(flipper_length_mm)), 
         bill_length_standardized = as.double(scale(bill_length_mm)))

penguin_data &lt;- data |&gt; select(flipper_length_standardized, 
bill_length_standardized)

write_csv(penguin_data, &quot;data/penguins_standardized.csv&quot;)
</pre></div>
</div>
<p>\index{seed!set.seed}</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>library(tidyverse)
set.seed(1)
</pre></div>
</div>
<p>Now we can load and preview the data.</p>
<div class="highlight-{r, notranslate"><div class="highlight"><pre><span></span>penguin_data &lt;- read_csv(&quot;data/penguins_standardized.csv&quot;)
penguin_data
</pre></div>
</div>
<p>Next, we can create a scatter plot using this data set
to see if we can detect subtypes or groups in our data set.</p>
<p>\newpage</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>ggplot(data, aes(x = flipper_length_standardized, 
                 y = bill_length_standardized)) +
  geom_point() +
  xlab(&quot;Flipper Length (standardized)&quot;) +
  ylab(&quot;Bill Length (standardized)&quot;) + 
  theme(text = element_text(size = 12))
</pre></div>
</div>
<p>Based \index{ggplot}\index{ggplot!geom_point} on the visualization
in Figure &#64;ref(fig:10-toy-example-plot),
we might suspect there are a few subtypes of penguins within our data set.
We can see roughly 3 groups of observations in Figure &#64;ref(fig:10-toy-example-plot),
including:</p>
<ol class="simple">
<li><p>a small flipper and bill length group,</p></li>
<li><p>a small flipper length, but large bill length group, and</p></li>
<li><p>a large  flipper and bill length group.</p></li>
</ol>
<p>Data visualization is a great tool to give us a rough sense of such patterns
when we have a small number of variables.
But if we are to group data—and select the number of groups—as part of
a reproducible analysis, we need something a bit more automated.
Additionally, finding groups via visualization becomes more difficult
as we increase the number of variables we consider when clustering.
The way to rigorously separate the data into groups
is to use a clustering algorithm.
In this chapter, we will focus on the <em>K-means</em> algorithm,
\index{K-means} a widely used and often very effective clustering method,
combined with the <em>elbow method</em> \index{elbow method}
for selecting the number of clusters.
This procedure will separate the data into groups;
Figure &#64;ref(fig:10-toy-example-clustering) shows these groups
denoted by colored scatter points.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>ggplot(data, aes(y = bill_length_standardized, 
                 x = flipper_length_standardized, color = cluster)) +
  geom_point() +
  xlab(&quot;Flipper Length (standardized)&quot;) +
  ylab(&quot;Bill Length (standardized)&quot;) + 
  scale_color_manual(values= c(&quot;darkorange3&quot;, &quot;dodgerblue3&quot;, &quot;goldenrod1&quot;))
</pre></div>
</div>
<p>What are the labels for these groups? Unfortunately, we don’t have any. K-means,
like almost all clustering algorithms, just outputs meaningless “cluster labels”
that are typically whole numbers: 1, 2, 3, etc. But in a simple case like this,
where we can easily visualize the clusters on a scatter plot, we can give
human-made labels to the groups using their positions on
the plot:</p>
<ul class="simple">
<li><p>small flipper length and small bill length (<font color="#D55E00">orange cluster</font>),</p></li>
<li><p>small flipper length and large bill length (<font color="#0072B2">blue cluster</font>).</p></li>
<li><p>and large flipper length and large bill  length (<font color="#F0E442">yellow cluster</font>).</p></li>
</ul>
<p>Once we have made these determinations, we can use them to inform our species
classifications or ask further questions about our data. For example, we might
be interested in understanding the relationship between flipper length and bill
length, and that relationship may differ depending on the type of penguin we
have.</p>
</div>
<div class="section" id="k-means">
<h2>K-means<a class="headerlink" href="#k-means" title="Permalink to this headline">¶</a></h2>
<div class="section" id="measuring-cluster-quality">
<h3>Measuring cluster quality<a class="headerlink" href="#measuring-cluster-quality" title="Permalink to this headline">¶</a></h3>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>library(tidyverse)

clus1 &lt;- filter(data, cluster == 2) |&gt;
  select(bill_length_standardized, flipper_length_standardized)
</pre></div>
</div>
<p>The K-means algorithm is a procedure that groups data into K clusters.
It starts with an initial clustering of the data, and then iteratively
improves it by making adjustments to the assignment of data
to clusters until it cannot improve any further. But how do we measure
the “quality” of a clustering, and what does it mean to improve it?
In K-means clustering, we measure the quality of a cluster by its
\index{within-cluster sum-of-squared-distances|see{WSSD}}\index{WSSD}
<em>within-cluster sum-of-squared-distances</em> (WSSD). Computing this involves two steps.
First, we find the cluster centers by computing the mean of each variable
over data points in the cluster. For example, suppose we have a
cluster containing four observations, and we are using two variables, <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, to cluster the data.
Then we would compute the coordinates, <span class="math notranslate nohighlight">\(\mu_x\)</span> and <span class="math notranslate nohighlight">\(\mu_y\)</span>, of the cluster center via</p>
<div class="math notranslate nohighlight">
\[\mu_x = \frac{1}{4}(x_1+x_2+x_3+x_4) \quad \mu_y = \frac{1}{4}(y_1+y_2+y_3+y_4).\]</div>
<p>In the first cluster from the example, there are <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">nrow(clus1)</span></code> data points. These are shown with their cluster center
(<code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">paste(&quot;flipper_length_standardized</span> <span class="pre">=&quot;,</span> <span class="pre">round(mean(clus1$flipper_length_standardized),2))</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">paste(&quot;bill_length_standardized</span> <span class="pre">=&quot;,</span> <span class="pre">round(mean(clus1$bill_length_standardized),2))</span></code>) highlighted
in Figure &#64;ref(fig:10-toy-example-clus1-center).</p>
<p>(ref:10-toy-example-clus1-center) Cluster 1 from the <code class="docutils literal notranslate"><span class="pre">penguin_data</span></code> data set example. Observations are in blue, with the cluster center highlighted in red.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>base &lt;- ggplot(data, aes(x = flipper_length_standardized, y = bill_length_standardized)) +
  geom_point() +
  xlab(&quot;Flipper Length (standardized)&quot;) +
  ylab(&quot;Bill Length (standardized)&quot;)

base &lt;- ggplot(clus1) +
  geom_point(aes(y = bill_length_standardized, x = flipper_length_standardized),  
  col = &quot;dodgerblue3&quot;) +
  labs(x = &quot;Flipper Length (standardized)&quot;, y = &quot;Bill Length (standardized)&quot;) +
  xlim(c(
    min(clus1$flipper_length_standardized) - 0.25 * 
      sd(clus1$flipper_length_standardized),
    max(clus1$flipper_length_standardized) + 0.25 * 
      sd(clus1$flipper_length_standardized)
  )) +
  ylim(c(
    min(clus1$bill_length_standardized) - 0.25 * 
      sd(clus1$bill_length_standardized),
    max(clus1$bill_length_standardized) + 0.25 * 
      sd(clus1$bill_length_standardized)
  )) +
  geom_point(aes(y = mean(bill_length_standardized), 
                 x = mean(flipper_length_standardized)), 
             color = &quot;#F8766D&quot;, 
             size = 5) +
  theme(legend.position = &quot;none&quot;)

base
</pre></div>
</div>
<p>The second step in computing the WSSD is to add up the squared distance
\index{distance!K-means} between each point in the cluster
and the cluster center.
We use the straight-line / Euclidean distance formula
that we learned about in Chapter &#64;ref(classification).
In the <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">nrow(clus1)</span></code>-observation cluster example above,
we would compute the WSSD <span class="math notranslate nohighlight">\(S^2\)</span> via</p>
<p>\begin{align*}
S^2 = \left((x_1 - \mu_x)^2 + (y_1 - \mu_y)^2\right) + \left((x_2 - \mu_x)^2 + (y_2 - \mu_y)^2\right) + \ \left((x_3 - \mu_x)^2 + (y_3 - \mu_y)^2\right)  +  \left((x_4 - \mu_x)^2 + (y_4 - \mu_y)^2\right).
\end{align*}</p>
<p>These distances are denoted by lines in Figure &#64;ref(fig:10-toy-example-clus1-dists) for the first cluster of the penguin data example.</p>
<p>(ref:10-toy-example-clus1-dists) Cluster 1 from the <code class="docutils literal notranslate"><span class="pre">penguin_data</span></code> data set example. Observations are in blue, with the cluster center highlighted in red. The distances from the observations to the cluster center are represented as black lines.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>base &lt;- ggplot(clus1) +
  geom_point(aes(y = bill_length_standardized, 
                 x = flipper_length_standardized),
             col = &quot;dodgerblue3&quot;) +
  labs(x = &quot;Flipper Length (standardized)&quot;, y = &quot;Bill Length (standardized)&quot;) +
  theme(legend.position = &quot;none&quot;) 

mn &lt;- clus1 |&gt; 
  summarize(flipper_length_standardized = mean(flipper_length_standardized), 
            bill_length_standardized = mean(bill_length_standardized))
for (i in 1:nrow(clus1)) {
  base &lt;- base + geom_segment(
    x = unlist(mn[1, &quot;flipper_length_standardized&quot;]), 
    y = unlist(mn[1, &quot;bill_length_standardized&quot;]),
    xend = unlist(clus1[i, &quot;flipper_length_standardized&quot;]), 
    yend = unlist(clus1[i, &quot;bill_length_standardized&quot;])
  )
}
base &lt;- base + 
  geom_point(aes(y = mean(bill_length_standardized), 
                 x = mean(flipper_length_standardized)), 
             color = &quot;#F8766D&quot;, 
             size = 5)
base
</pre></div>
</div>
<p>The larger the value of <span class="math notranslate nohighlight">\(S^2\)</span>, the more spread out the cluster is, since large <span class="math notranslate nohighlight">\(S^2\)</span> means that points are far from the cluster center.
Note, however, that “large” is relative to <em>both</em> the scale of the variables for clustering <em>and</em> the number of points in the cluster. A cluster where points are very close to the center might still have a large <span class="math notranslate nohighlight">\(S^2\)</span> if there are many data points in the cluster.</p>
<p>After we have calculated the WSSD for all the clusters,
we sum them together to get the <em>total WSSD</em>.
For our example,
this means adding up all the squared distances for the 18 observations.
These distances are denoted by black lines in
Figure &#64;ref(fig:10-toy-example-all-clus-dists).</p>
<p>(ref:10-toy-example-all-clus-dists) All clusters from the <code class="docutils literal notranslate"><span class="pre">penguin_data</span></code> data set example. Observations are in orange, blue, and yellow with the cluster center highlighted in red. The distances from the observations to each of the respective cluster centers are represented as black lines.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>

all_clusters_base &lt;- data |&gt;
  ggplot(aes(y = bill_length_standardized,
             x = flipper_length_standardized,
             color = cluster)) +
  geom_point() +
  xlab(&quot;Flipper Length (standardized)&quot;) +
  ylab(&quot;Bill Length (standardized)&quot;) + 
  scale_color_manual(values= c(&quot;darkorange3&quot;, 
                               &quot;dodgerblue3&quot;, 
                               &quot;goldenrod1&quot;))
cluster_centers &lt;- tibble(x = c(0, 0, 0),
                          y = c(0, 0, 0))

for (cluster_number in seq_along(1:3)) {
  
  clus &lt;- filter(data, cluster == cluster_number) |&gt;
    select(bill_length_standardized, flipper_length_standardized)
  
  mn &lt;- clus |&gt; 
    summarize(flipper_length_standardized = mean(flipper_length_standardized),
              bill_length_standardized = mean(bill_length_standardized))
  
  for (i in 1:nrow(clus)) {
    all_clusters_base &lt;- all_clusters_base + 
      geom_segment(x = unlist(mn[1, &quot;flipper_length_standardized&quot;]), 
                   y = unlist(mn[1, &quot;bill_length_standardized&quot;]),
      xend = unlist(clus[i, &quot;flipper_length_standardized&quot;]), 
      yend = unlist(clus[i, &quot;bill_length_standardized&quot;]),
      color = &quot;black&quot;
    )
  }
  
  #all_clusters_base &lt;- all_clusters_base + 
  #  geom_point(aes(y = mean(clus$bill_length_standardized), 
  #                 x = mean(clus$flipper_length_standardized)), 
  #                 color = &quot;#F8766D&quot;, size = 3)
  #print(mean(clus$bill_length_standardized))
  #print(mean(clus$flipper_length_standardized))
  cluster_centers[cluster_number, 1] &lt;- mean(clus$flipper_length_standardized)
  cluster_centers[cluster_number, 2] &lt;- mean(clus$bill_length_standardized)
}

all_clusters_base &lt;- all_clusters_base + 
  geom_point(aes(y = cluster_centers$y[1], 
                 x = cluster_centers$x[1]), 
             color = &quot;#F8766D&quot;, size = 3) +
  geom_point(aes(y = cluster_centers$y[2], 
                 x = cluster_centers$x[2]), 
             color = &quot;#F8766D&quot;, size = 3) +
  geom_point(aes(y = cluster_centers$y[3], 
                 x = cluster_centers$x[3]), 
             color = &quot;#F8766D&quot;, size = 3)

all_clusters_base
</pre></div>
</div>
<p>\newpage</p>
</div>
<div class="section" id="the-clustering-algorithm">
<h3>The clustering algorithm<a class="headerlink" href="#the-clustering-algorithm" title="Permalink to this headline">¶</a></h3>
<p>We begin the K-means \index{K-means!algorithm} algorithm by picking K,
and randomly assigning a roughly equal number of observations
to each of the K clusters.
An example random initialization is shown in Figure &#64;ref(fig:10-toy-kmeans-init).</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>set.seed(14)
penguin_data[&quot;label&quot;] &lt;- factor(sample(1:3, nrow(penguin_data), replace = TRUE))

plt_lbl &lt;- ggplot(penguin_data, aes(y = bill_length_standardized, 
                                    x = flipper_length_standardized, 
                                    color = label)) +
  geom_point(size = 2) +
  xlab(&quot;Flipper Length (standardized)&quot;) +
  ylab(&quot;Bill Length (standardized)&quot;) +
  theme(legend.position = &quot;none&quot;) + 
  scale_color_manual(values= cbpalette)

plt_lbl
</pre></div>
</div>
<p>Then K-means consists of two major steps that attempt to minimize the
sum of WSSDs over all the clusters, i.e., the \index{WSSD!total} <em>total WSSD</em>:</p>
<ol class="simple">
<li><p><strong>Center update:</strong> Compute the center of each cluster.</p></li>
<li><p><strong>Label update:</strong> Reassign each data point to the cluster with the nearest center.</p></li>
</ol>
<p>These two steps are repeated until the cluster assignments no longer change.
We show what the first four iterations of K-means would look like in<br />
Figure &#64;ref(fig:10-toy-kmeans-iter).
There each row corresponds to an iteration,
where the left column depicts the center update,
and the right column depicts the reassignment of data to clusters.</p>
<p>(ref:10-toy-kmeans-iter) First four iterations of K-means clustering on the <code class="docutils literal notranslate"><span class="pre">penguin_data</span></code> example data set. Each pair of plots corresponds to an iteration. Within the pair, the first plot depicts the center update, and the second plot depicts the reassignment of data to clusters. Cluster centers are indicated by larger points that are outlined in black.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>list_plot_cntrs &lt;- vector(mode = &quot;list&quot;, length = 4)
list_plot_lbls &lt;- vector(mode = &quot;list&quot;, length = 4)

for (i in 1:4) {
  # compute centers
  centers &lt;- penguin_data |&gt;
    group_by(label) |&gt;
    summarize_all(funs(mean))
  nclus &lt;- nrow(centers)
  # replot with centers
  plt_ctr &lt;- ggplot(penguin_data, aes(y = bill_length_standardized, 
                                      x = flipper_length_standardized, 
                                      color = label)) +
    geom_point(size = 2) +
    xlab(&quot;Flipper Length\n(standardized)&quot;) +
    ylab(&quot;Bill Length\n(standardized)&quot;) +
    theme(legend.position = &quot;none&quot;) +
    scale_color_manual(values= cbpalette) + 
    geom_point(data = centers, 
               aes(y = bill_length_standardized, 
                                   x = flipper_length_standardized, 
                                   fill = label), 
               size = 4, 
               shape = 21, 
               stroke = 1, 
               color = &quot;black&quot;, 
               fill = cbpalette) +
    annotate(&quot;text&quot;, x = -0.5, y = 1.5, label = paste0(&quot;Iteration &quot;, i), size = 5)+ 
    theme(text = element_text(size = 14), axis.title=element_text(size=14)) 
  
  if (i == 1 | i == 2) {
    plt_ctr &lt;- plt_ctr +
      ggtitle(&quot;Center Update&quot;)
  }
  
  # reassign labels
  dists &lt;- rbind(centers, penguin_data) |&gt;
    select(&quot;flipper_length_standardized&quot;, &quot;bill_length_standardized&quot;) |&gt;
    dist() |&gt;
    as.matrix()
  dists &lt;- as_tibble(dists[-(1:nclus), 1:nclus])
  penguin_data &lt;- penguin_data |&gt; 
    mutate(label = apply(dists, 1, function(x) names(x)[which.min(x)]))

  plt_lbl &lt;- ggplot(penguin_data, 
                    aes(y = bill_length_standardized, 
                        x = flipper_length_standardized, 
                        color = label)) +
    geom_point(size = 2) +
    xlab(&quot;Flipper Length\n(standardized)&quot;) +
    ylab(&quot;Bill Length\n(standardized)&quot;) +
    theme(legend.position = &quot;none&quot;) +
    scale_color_manual(values= cbpalette) +
    geom_point(data = centers, 
               aes(y = bill_length_standardized, 
                   x = flipper_length_standardized, fill = label), 
               size = 4, 
               shape = 21, 
               stroke = 1, 
               color = &quot;black&quot;, 
               fill = cbpalette) +
    annotate(&quot;text&quot;, x = -0.5, y = 1.5, label = paste0(&quot;Iteration &quot;, i), size = 5) + 
    theme(text = element_text(size = 14), axis.title=element_text(size=14)) 

  if (i == 1 | i ==2) {
    plt_lbl &lt;- plt_lbl +
      ggtitle(&quot;Label Update&quot;)
  }
  
  list_plot_cntrs[[i]] &lt;- plt_ctr
  list_plot_lbls[[i]] &lt;- plt_lbl
}

iter_plot_list &lt;- c(list_plot_cntrs[1], list_plot_lbls[1],
                    list_plot_cntrs[2], list_plot_lbls[2],
                    list_plot_cntrs[3], list_plot_lbls[3],
                    list_plot_cntrs[4], list_plot_lbls[4])

ggarrange(iter_plot_list[[1]] +
               theme(axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     axis.title.x = element_blank(), 
                     plot.margin = margin(r = 2, b = 2)), 
          iter_plot_list[[2]] + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     axis.title.x = element_blank(),
                     plot.margin = margin(r = 2, l = 2, b = 2) ), 
          iter_plot_list[[3]] + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     axis.title.x = element_blank(),
                     plot.margin = margin(r = 2, l = 2, b = 2)  ),
          iter_plot_list[[4]] + 
            theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(), 
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     axis.title.x = element_blank(),
                     plot.margin = margin(l = 2, b = 2)  ),
          iter_plot_list[[5]] +
               theme(plot.margin = margin(r = 2, t = 2)), 
          iter_plot_list[[6]] + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     plot.margin = margin(r = 2, l = 2, t = 2) ), 
          iter_plot_list[[7]] + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     plot.margin = margin(r = 2, l = 2, t = 2)  ),
          iter_plot_list[[8]] + theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(), 
                     plot.margin = margin(l = 2, t = 2)  ),
           nrow = 2)
</pre></div>
</div>
<p>Note that at this point, we can terminate the algorithm since none of the assignments changed
in the fourth iteration; both the centers and labels will remain the same from this point onward.</p>
<blockquote>
<div><p><strong>Note:</strong> Is K-means <em>guaranteed</em> to stop at some point, or could it iterate forever? As it turns out,
thankfully, the answer is that K-means \index{K-means!termination} is guaranteed to stop after <em>some</em> number of iterations. For the interested reader, the
logic for this has three steps: (1) both the label update and the center update decrease total WSSD in each iteration,
(2) the total WSSD is always greater than or equal to 0, and (3) there are only a finite number of possible
ways to assign the data to clusters. So at some point, the total WSSD must stop decreasing, which means none of the assignments
are changing, and the algorithm terminates.</p>
</div></blockquote>
<p>What kind of data is suitable for K-means clustering?
In the simplest version of K-means clustering that we have presented here,
the straight-line distance is used to measure the
distance between observations and cluster centers.
This means that only quantitative data should be used with this algorithm.
There are variants on the K-means algorithm,
as well as other clustering algorithms entirely,
that use other distance metrics
to allow for non-quantitative data to be clustered.
These, however, are beyond the scope of this book.</p>
</div>
<div class="section" id="random-restarts">
<h3>Random restarts<a class="headerlink" href="#random-restarts" title="Permalink to this headline">¶</a></h3>
<p>Unlike the classification and regression models we studied in previous chapters, K-means \index{K-means!restart, nstart} can get “stuck” in a bad solution.
For example, Figure &#64;ref(fig:10-toy-kmeans-bad-init) illustrates an unlucky random initialization by K-means.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>penguin_data &lt;- penguin_data |&gt;
  mutate(label = as_factor(c(3L, 3L, 1L, 1L, 2L, 1L, 2L, 1L, 1L, 
                             1L, 3L, 1L, 2L, 2L, 2L, 3L, 3L, 3L)))

plt_lbl &lt;- ggplot(penguin_data, aes(y = bill_length_standardized, 
                                    x = flipper_length_standardized, 
                                    color = label)) +
  geom_point(size = 2) +
  xlab(&quot;Flipper Length (standardized)&quot;) +
  ylab(&quot;Bill Length (standardized)&quot;) +
  scale_color_manual(values= cbpalette) +
  theme(legend.position = &quot;none&quot;)

plt_lbl
</pre></div>
</div>
<p>Figure &#64;ref(fig:10-toy-kmeans-bad-iter) shows what the iterations of K-means would look like with the unlucky random initialization shown in Figure &#64;ref(fig:10-toy-kmeans-bad-init).</p>
<p>(ref:10-toy-kmeans-bad-iter) First five iterations of K-means clustering on the <code class="docutils literal notranslate"><span class="pre">penguin_data</span></code> example data set with a poor random initialization. Each pair of plots corresponds to an iteration. Within the pair, the first plot depicts the center update, and the second plot depicts the reassignment of data to clusters. Cluster centers are indicated by larger points that are outlined in black.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>list_plot_cntrs &lt;- vector(mode = &quot;list&quot;, length = 5)
list_plot_lbls &lt;- vector(mode = &quot;list&quot;, length = 5)

for (i in 1:5) {
  # compute centers
  centers &lt;- penguin_data |&gt;
    group_by(label) |&gt;
    summarize_all(funs(mean))
  nclus &lt;- nrow(centers)
  # replot with centers
  plt_ctr &lt;- ggplot(penguin_data, aes(y = bill_length_standardized, 
                                      x = flipper_length_standardized, 
                                      color = label)) +
    geom_point(size = 2) +
    xlab(&quot;Flipper Length\n(standardized)&quot;) +
    ylab(&quot;Bill Length\n(standardized)&quot;) +
    theme(legend.position = &quot;none&quot;) +
    scale_color_manual(values= cbpalette) + 
    geom_point(data = centers, aes(y = bill_length_standardized, 
                                   x = flipper_length_standardized, 
                                   fill = label), 
               size = 4, 
               shape = 21, 
               stroke = 1, 
               color = &quot;black&quot;, 
               fill = cbpalette) +
    annotate(&quot;text&quot;, x = -0.5, y = 1.5, label = paste0(&quot;Iteration &quot;, i), size = 5) + 
    theme(text = element_text(size = 14), axis.title=element_text(size=14)) 

  if (i == 1 | i == 2) {
    plt_ctr &lt;- plt_ctr +
      ggtitle(&quot;Center Update&quot;)
  }
  
  # reassign labels
  dists &lt;- rbind(centers, penguin_data) |&gt;
    select(&quot;flipper_length_standardized&quot;, &quot;bill_length_standardized&quot;) |&gt;
    dist() |&gt;
    as.matrix()
  dists &lt;- as_tibble(dists[-(1:nclus), 1:nclus])
  penguin_data &lt;- penguin_data |&gt; 
    mutate(label = apply(dists, 1, function(x) names(x)[which.min(x)]))

  plt_lbl &lt;- ggplot(penguin_data, aes(y = bill_length_standardized, 
                                      x = flipper_length_standardized, 
                                      color = label)) +
    geom_point(size = 2) +
    xlab(&quot;Flipper Length\n(standardized)&quot;) +
    ylab(&quot;Bill Length\n(standardized)&quot;) +
    theme(legend.position = &quot;none&quot;) +
    scale_color_manual(values= cbpalette) +
    geom_point(data = centers, aes(y = bill_length_standardized, 
                                   x = flipper_length_standardized, 
                                   fill = label), 
               size = 4, 
               shape = 21, 
               stroke = 1, 
               color = &quot;black&quot;, 
               fill = cbpalette) +
    annotate(&quot;text&quot;, x = -0.5, y = 1.5, label = paste0(&quot;Iteration &quot;, i), size = 5) + 
    theme(text = element_text(size = 14), axis.title=element_text(size=14)) 

  if (i == 1 | i == 2) {
    plt_lbl &lt;- plt_lbl +
      ggtitle(&quot;Label Update&quot;)
  }
  
  list_plot_cntrs[[i]] &lt;- plt_ctr
  list_plot_lbls[[i]] &lt;- plt_lbl
}

iter_plot_list &lt;- c(list_plot_cntrs[1], list_plot_lbls[1],
                    list_plot_cntrs[2], list_plot_lbls[2],
                    list_plot_cntrs[3], list_plot_lbls[3],
                    list_plot_cntrs[4], list_plot_lbls[4],
                    list_plot_cntrs[5], list_plot_lbls[5])

ggarrange(iter_plot_list[[1]] +
               theme(axis.text.x = element_blank(),  #remove x axis
                     axis.ticks.x = element_blank(),
                     axis.title.x = element_blank(), 
                     plot.margin = margin(r = 2, b = 2)), # change margins
          iter_plot_list[[2]] + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     axis.title.x = element_blank(),
                     plot.margin = margin(r = 2, l = 2, b = 2) ), 
          iter_plot_list[[3]] + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     axis.title.x = element_blank(),
                     plot.margin = margin(r = 2, l = 2, b = 2)),
          iter_plot_list[[4]] + 
            theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(), 
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     axis.title.x = element_blank(),
                     plot.margin = margin(l = 2, b = 2) ),
          iter_plot_list[[5]] +
               theme(axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     axis.title.x = element_blank(),
                     plot.margin = margin(r = 2, t = 2, b = 2)),
          iter_plot_list[[6]] + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     axis.title.x = element_blank(),
                     plot.margin = margin(r = 2, l = 2, t = 2, b = 2) ), 
          iter_plot_list[[7]] + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     plot.margin = margin(r = 2, l = 2, t = 2, b = 2)  ),
          iter_plot_list[[8]] + theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(), 
                     plot.margin = margin(l = 2, t = 2, b = 2)),  
          ggplot() + theme_void(), ggplot() + theme_void(), ggplot() + theme_void(), ggplot() + theme_void(), # adding third row of empty plots to change space between third and fourth row
          iter_plot_list[[9]] + 
               theme(plot.margin = margin(r = 2)),
          iter_plot_list[[10]] + 
            theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(), 
                     plot.margin = margin(l = 2)  ),
         heights = c(3, 3, -1, 3),
          ncol = 4)
</pre></div>
</div>
<p>This looks like a relatively bad clustering of the data, but K-means cannot improve it.
To solve this problem when clustering data using K-means, we should randomly re-initialize the labels a few times, run K-means for each initialization,
and pick the clustering that has the lowest final total WSSD.</p>
</div>
<div class="section" id="choosing-k">
<h3>Choosing K<a class="headerlink" href="#choosing-k" title="Permalink to this headline">¶</a></h3>
<p>In order to cluster data using K-means,
we also have to pick the number of clusters, K.
But unlike in classification, we have no response variable
and cannot perform cross-validation with some measure of model prediction error.
Further, if K is chosen too small, then multiple clusters get grouped together;
if K is too large, then clusters get subdivided.
In both cases, we will potentially miss interesting structure in the data.
Figure &#64;ref(fig:10-toy-kmeans-vary-k) illustrates the impact of K
on K-means clustering of our penguin flipper and bill length data
by showing the different clusterings for K’s ranging from 1 to 9.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>set.seed(3)

kclusts &lt;- tibble(k = 1:9) |&gt;
  mutate(
    kclust = map(k, ~ kmeans(penguin_data[-3], .x)),
    tidied = map(kclust, tidy),
    glanced = map(kclust, glance),
    augmented = map(kclust, augment, penguin_data[-3])
  )

clusters &lt;- kclusts |&gt;
  unnest(tidied)

assignments &lt;- kclusts |&gt;
  unnest(augmented)

clusterings &lt;- kclusts |&gt;
  unnest(glanced, .drop = TRUE)

clusters_levels &lt;- c(&quot;1 Cluster&quot;, 
                     &quot;2 Clusters&quot;, 
                     &quot;3 Clusters&quot;, 
                     &quot;4 Clusters&quot;, 
                     &quot;5 Clusters&quot;, 
                     &quot;6 Clusters&quot;, 
                     &quot;7 Clusters&quot;, 
                     &quot;8 Clusters&quot;, 
                     &quot;9 Clusters&quot;)

assignments$k &lt;- factor(assignments$k)
levels(assignments$k) &lt;- clusters_levels

clusters$k &lt;- factor(clusters$k)
levels(clusters$k) &lt;- clusters_levels

p1 &lt;- ggplot(assignments, aes(flipper_length_standardized, 
                              bill_length_standardized)) +
  geom_point(aes(color = .cluster, size = I(2))) +
  facet_wrap(~k) +   scale_color_manual(values = cbbPalette) +
  labs(x = &quot;Flipper Length (standardized)&quot;, 
       y = &quot;Bill Length (standardized)&quot;, 
       color = &quot;Cluster&quot;) +
  theme(legend.position = &quot;none&quot;) +
  geom_point(data = clusters, 
             aes(fill = cluster), 
             color = &quot;black&quot;, 
             size = 4, 
             shape = 21, 
             stroke = 1) + 
  scale_fill_manual(values = cbbPalette) +     
  theme(text = element_text(size = 12), axis.title=element_text(size=12)) 


p1
</pre></div>
</div>
<p>If we set K less than 3, then the clustering merges separate groups of data; this causes a large
total WSSD, since the cluster center (denoted by an “x”) is not close to any of the data in the cluster. On
the other hand, if we set K greater than 3, the clustering subdivides subgroups of data; this does indeed still
decrease the total WSSD, but by only a <em>diminishing amount</em>. If we plot the total WSSD versus the number of
clusters, we see that the decrease in total WSSD levels off (or forms an “elbow shape”) \index{elbow method} when we reach roughly
the right number of clusters (Figure &#64;ref(fig:10-toy-kmeans-elbow)).</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>p2 &lt;- ggplot(clusterings, aes(x = k, y = tot.withinss)) +
  geom_point(size = 2) +
  geom_line() +
  # annotate(geom = &quot;line&quot;, x = 4, y = 35, xend = 2.65, yend = 27, arrow = arrow(length = unit(2, &quot;mm&quot;))) +
  geom_segment(aes(x = 4, y = 17, 
                   xend = 3.1, 
                   yend = 6), 
               arrow = arrow(length = unit(0.2, &quot;cm&quot;))) +
  annotate(&quot;text&quot;, x = 4.4, y = 19, label = &quot;Elbow&quot;, size = 7, color = &quot;blue&quot;) +
  labs(x = &quot;Number of Clusters&quot;, y = &quot;Total WSSD&quot;) +
  #theme(text = element_text(size = 20)) +
  scale_x_continuous(breaks = 1:9)
p2
</pre></div>
</div>
</div>
</div>
<div class="section" id="data-pre-processing-for-k-means">
<h2>Data pre-processing for K-means<a class="headerlink" href="#data-pre-processing-for-k-means" title="Permalink to this headline">¶</a></h2>
<p>Similar to K-nearest neighbors classification and regression, K-means
clustering uses straight-line distance to decide which points are similar to
each other. Therefore, the <em>scale</em> of each of the variables in the data
will influence which cluster data points end up being assigned.
Variables with a large scale will have a much larger
effect on deciding cluster assignment than variables with a small scale.
To address this problem, we typically standardize \index{standardization!K-means}\index{K-means!standardization} our data before clustering,
which ensures that each variable has a mean of 0 and standard deviation of 1.
The <code class="docutils literal notranslate"><span class="pre">scale</span></code> function in R can be used to do this.
We show an example of how to use this function
below using an unscaled and unstandardized version of the data set in this chapter.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>unstandardized_data &lt;- read_csv(&quot;data/toy_penguins.csv&quot;) |&gt;
  select(bill_length_mm, flipper_length_mm)

write_csv(unstandardized_data, &quot;data/penguins_not_standardized.csv&quot;)
</pre></div>
</div>
<p>First, here is what the raw (i.e., not standardized) data looks like:</p>
<p>And then we apply the <code class="docutils literal notranslate"><span class="pre">scale</span></code> function to every column in the data frame
using <code class="docutils literal notranslate"><span class="pre">mutate</span></code> + <code class="docutils literal notranslate"><span class="pre">across</span></code>.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>standardized_data &lt;- not_standardized_data |&gt;
  mutate(across(everything(), scale))

standardized_data
</pre></div>
</div>
</div>
<div class="section" id="k-means-in-r">
<h2>K-means in R<a class="headerlink" href="#k-means-in-r" title="Permalink to this headline">¶</a></h2>
<p>To perform K-means clustering in R, we use the <code class="docutils literal notranslate"><span class="pre">kmeans</span></code> function. \index{K-means!kmeans function} It takes at
least two arguments: the data frame containing the data you wish to cluster,
and K, the number of clusters (here we choose K = 3). Note that since the K-means
algorithm uses a random initialization of assignments, but since we set the random seed
earlier, the clustering will be reproducible.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span># hidden seed
set.seed(1234)
</pre></div>
</div>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>penguin_clust &lt;- kmeans(standardized_data, centers = 3)
penguin_clust
</pre></div>
</div>
<p>As you can see above, the clustering object returned by <code class="docutils literal notranslate"><span class="pre">kmeans</span></code> has a lot of information
that can be used to visualize the clusters, pick K, and evaluate the total WSSD.
To obtain this information in a tidy format, we will call in help
from the <code class="docutils literal notranslate"><span class="pre">broom</span></code> package. \index{broom} Let’s start by visualizing the clustering
as a colored scatter plot. To do that,
we use the <code class="docutils literal notranslate"><span class="pre">augment</span></code> function, \index{K-means!augment} \index{augment} which takes in the model and the original data
frame, and returns a data frame with the data and the cluster assignments for
each point:</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>library(broom)

clustered_data &lt;- augment(penguin_clust, standardized_data)
clustered_data
</pre></div>
</div>
<p>Now that we have this information in a tidy data frame, we can make a visualization
of the cluster assignments for each point, as shown in Figure &#64;ref(fig:10-plot-clusters-2).</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>cluster_plot &lt;- ggplot(clustered_data,
  aes(x = flipper_length_mm, 
      y = bill_length_mm, 
      color = .cluster), 
  size = 2) +
  geom_point() +
  labs(x = &quot;Flipper Length (standardized)&quot;, 
       y = &quot;Bill Length (standardized)&quot;, 
       color = &quot;Cluster&quot;) + 
  scale_color_manual(values = c(&quot;dodgerblue3&quot;,
                                &quot;darkorange3&quot;,  
                                &quot;goldenrod1&quot;)) + 
  theme(text = element_text(size = 12))

cluster_plot
</pre></div>
</div>
<p>As mentioned above, we also need to select K by finding
where the “elbow” occurs in the plot of total WSSD versus the number of clusters.
We can obtain the total WSSD (<code class="docutils literal notranslate"><span class="pre">tot.withinss</span></code>) \index{WSSD!total} from our
clustering using <code class="docutils literal notranslate"><span class="pre">broom</span></code>’s <code class="docutils literal notranslate"><span class="pre">glance</span></code> function. For example:</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>glance(penguin_clust)
</pre></div>
</div>
<p>To calculate the total WSSD for a variety of Ks, we will
create a data frame with a column named <code class="docutils literal notranslate"><span class="pre">k</span></code> with rows containing
each value of K we want to run K-means with (here, 1 to 9).</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>penguin_clust_ks &lt;- tibble(k = 1:9)
penguin_clust_ks
</pre></div>
</div>
<p>Then we use <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> \index{rowwise} + <code class="docutils literal notranslate"><span class="pre">mutate</span></code> to apply the <code class="docutils literal notranslate"><span class="pre">kmeans</span></code> function
within each row to each K.
However, given that the <code class="docutils literal notranslate"><span class="pre">kmeans</span></code> function
returns a model object to us (not a vector),
we will need to store the results as a list column.
This works because both vectors and lists are legitimate
data structures for data frame columns.
To make this work,
we have to put each model object in a list using the <code class="docutils literal notranslate"><span class="pre">list</span></code> function.
We demonstrate how to do this below:</p>
<p>If we take a look at our data frame <code class="docutils literal notranslate"><span class="pre">penguin_clust_ks</span></code> now,
we see that it has two columns: one with the value for K,
and the other holding the clustering model object in a list column.</p>
<p>If we wanted to get one of the clusterings out
of the list column in the data frame,
we could use a familiar friend: <code class="docutils literal notranslate"><span class="pre">pull</span></code>.
<code class="docutils literal notranslate"><span class="pre">pull</span></code> will return to us a data frame column as a simpler data structure,
here that would be a list.
And then to extract the first item of the list,
we can use the <code class="docutils literal notranslate"><span class="pre">pluck</span></code> function. We pass<br />
it the index for the element we would like to extract
(here, <code class="docutils literal notranslate"><span class="pre">1</span></code>).</p>
<p>Next, we use <code class="docutils literal notranslate"><span class="pre">mutate</span></code> again to apply <code class="docutils literal notranslate"><span class="pre">glance</span></code> \index{glance}
to each of the K-means clustering objects to get the clustering statistics
(including WSSD).
The output of <code class="docutils literal notranslate"><span class="pre">glance</span></code> is a data frame,
and so we need to create another list column (using <code class="docutils literal notranslate"><span class="pre">list</span></code>) for this to work.
This results in a complex data frame with 3 columns, one for K, one for the
K-means clustering objects, and one for the clustering statistics:</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>penguin_clust_ks &lt;- tibble(k = 1:9) |&gt;
  rowwise() |&gt;
  mutate(penguin_clusts = list(kmeans(standardized_data, k)),
         glanced = list(glance(penguin_clusts)))

penguin_clust_ks
</pre></div>
</div>
<p>Finally we extract the total WSSD from the column named <code class="docutils literal notranslate"><span class="pre">glanced</span></code>.
Given that each item in this list column is a data frame,
we will need to use the <code class="docutils literal notranslate"><span class="pre">unnest</span></code> function
to unpack the data frames into simpler column data types.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>clustering_statistics &lt;- penguin_clust_ks |&gt;
  unnest(glanced)

clustering_statistics
</pre></div>
</div>
<p>Now that we have <code class="docutils literal notranslate"><span class="pre">tot.withinss</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code> as columns in a data frame, we can make a line plot
(Figure &#64;ref(fig:10-plot-choose-k)) and search for the “elbow” to find which value of K to use.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>elbow_plot &lt;- ggplot(clustering_statistics, aes(x = k, y = tot.withinss)) +
  geom_point() +
  geom_line() +
  xlab(&quot;K&quot;) +
  ylab(&quot;Total within-cluster sum of squares&quot;) +
  scale_x_continuous(breaks = 1:9) + 
  theme(text = element_text(size = 12))

elbow_plot
</pre></div>
</div>
<p>It looks like 3 clusters is the right choice for this data.
But why is there a “bump” in the total WSSD plot here?
Shouldn’t total WSSD always decrease as we add more clusters?
Technically yes, but remember:  K-means can get “stuck” in a bad solution.
Unfortunately, for K = 8 we had an unlucky initialization
and found a bad clustering! \index{K-means!restart, nstart}
We can help prevent finding a bad clustering
by trying a few different random initializations
via the <code class="docutils literal notranslate"><span class="pre">nstart</span></code> argument (Figure &#64;ref(fig:10-choose-k-nstart)
shows a setup where we use 10 restarts).
When we do this, K-means clustering will be performed
the number of times specified by the <code class="docutils literal notranslate"><span class="pre">nstart</span></code> argument,
and R will return to us the best clustering from this.
The more times we perform K-means clustering,
the more likely we are to find a good clustering (if one exists).
What value should you choose for <code class="docutils literal notranslate"><span class="pre">nstart</span></code>? The answer is that it depends
on many factors: the size and characteristics of your data set,
as well as the speed and size of your computer.
The larger the <code class="docutils literal notranslate"><span class="pre">nstart</span></code> value the better from an analysis perspective,
but there is a trade-off that doing many clusterings
could take a long time.
So this is something that needs to be balanced.</p>
<div class="highlight-{r notranslate"><div class="highlight"><pre><span></span>penguin_clust_ks &lt;- tibble(k = 1:9) |&gt;
  rowwise() |&gt;
  mutate(penguin_clusts = list(kmeans(standardized_data, nstart = 10, k)),
         glanced = list(glance(penguin_clusts)))

clustering_statistics &lt;- penguin_clust_ks |&gt;
  unnest(glanced)

elbow_plot &lt;- ggplot(clustering_statistics, aes(x = k, y = tot.withinss)) +
  geom_point() +
  geom_line() +
  xlab(&quot;K&quot;) +
  ylab(&quot;Total within-cluster sum of squares&quot;) +
  scale_x_continuous(breaks = 1:9) + 
  theme(text = element_text(size = 12))

elbow_plot
</pre></div>
</div>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<p>Practice exercises for the material covered in this chapter
can be found in the accompanying
<a class="reference external" href="https://github.com/UBC-DSCI/data-science-a-first-intro-worksheets#readme">worksheets repository</a>
in the “Clustering” row.
You can launch an interactive version of the worksheet in your browser by clicking the “launch binder” button.
You can also preview a non-interactive version of the worksheet by clicking “view worksheet.”
If you instead decide to download the worksheet and run it on your own machine,
make sure to follow the instructions for computer setup
found in Chapter &#64;ref(move-to-your-own-machine). This will ensure that the automated feedback
and guidance that the worksheets provide will function as intended.</p>
</div>
<div class="section" id="additional-resources">
<h2>Additional resources<a class="headerlink" href="#additional-resources" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Chapter 10 of <em>An Introduction to Statistical
Learning</em> [&#64;james2013introduction] provides a
great next stop in the process of learning about clustering and unsupervised
learning in general. In the realm of clustering specifically, it provides a
great companion introduction to K-means, but also covers <em>hierarchical</em>
clustering for when you expect there to be subgroups, and then subgroups within
subgroups, etc., in your data. In the realm of more general unsupervised
learning, it covers <em>principal components analysis (PCA)</em>, which is a very
popular technique for reducing the number of predictors in a dataset.</p></li>
</ul>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="regression2.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Regression II: linear regression {#regression2}</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="inference.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Statistical inference {#inference}</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By UBC<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>